-
    Testing for hierarchical search in M2M
-
    !python {model: res.partner }: |
        ids = self.search(cr, uid, [('category_id', 'child_of','supplier')])
        assert len(ids) >= 1, ids

-
    Test hierarchical search in M2M with child ID1
-
    !python {model: res.partner }: |
        ids = self.search(cr, uid, [('category_id', 'child_of','Components Supplier')])
        assert len(ids) >= 1, ids
-
    Test hierarchical search in M2M with child ID2
-
    !python {model: res.partner }: |
        ids = self.search(cr, uid, [('category_id', 'child_of','Miscellaneous Suppliers')])
        assert len(ids) >= 1, ids

-
    "1.0 Setup test partner categories: parent root"
-
    !record {model: res.partner.category, id: categ_root}:
        name: Root category
-
    "1.1 Setup test partner categories: parent category"
-
    !record {model: res.partner.category, id: categ_0}:
        name: Parent category
        parent_id: categ_root
-
    "1.2 Setup test partner categories: child 1"
-
    !record {model: res.partner.category, id: categ_1}:
        name: Child 1
        parent_id: categ_0
-
    Test hierarchical search in M2M with child ID (list of ids)
-
    !python {model: res.partner.category }: |
        ids = self.search(cr, uid, [('id', 'child_of',[ref('categ_root')])])
        assert len(ids) == 3, ids
-
    Test hierarchical search in M2M with child ID (single id)
-
    !python {model: res.partner.category }: |
        ids = self.search(cr, uid, [('id', 'child_of',ref('categ_root'))])
        assert len(ids) == 3, ids
-
    Test hierarchical search in M2M with child IDs
-
    !python {model: res.partner.category }: |
        ids = self.search(cr, uid, [('id', 'child_of',[ref('categ_1'), ref('categ_0')])])
        assert len(ids) == 2, ids
-
    Test hierarchical search in M2M with child IDs
-
    !python {model: res.partner.category }: |
        ids = self.search(cr, uid, [('id', 'child_of',[ref('categ_0')])])
        assert len(ids) == 2, ids
-
    Test hierarchical search in M2M with child IDs
-
    !python {model: res.partner.category }: |
        ids = self.search(cr, uid, [('id', 'child_of',[ref('categ_1')])])
        assert len(ids) == 1, ids
-
    Testing that some domain expressions work
-
    !python {model: res.partner.address }: |
        ids = self.search(cr, uid, [('partner_id','=','Agrolait')])
        assert len(ids) >= 1, ids
-
    Trying the "in" operator, for scalar value
-
    !python {model: res.partner.address }: |
        ids = self.search(cr, uid, [('partner_id','in','Agrolait')])
        assert len(ids) >= 1, ids
-
    Trying the "in" operator for list value
-
    !python {model: res.partner.address }: |
        ids = self.search(cr, uid, [('partner_id','in',['Agrolait','ASUStek'])])
        assert len(ids) >= 1, ids
-
    Check we can use "in" operator for plain fields.
-
    !python {model: ir.ui.menu }: |
        ids = self.search(cr, uid, [('sequence','in',[1, 2, 10, 20])])
        assert len(ids) >= 1, ids
-
    Test one2many operator with empty search list
-
    !assert {model: res.partner, search: "[('address', 'in', [])]", count: 0, string: "Ids should be empty"}
-
    Test one2many operator with False
-
    !assert {model: res.partner, search: "[('address', '=', False)]"}:
        - address in (False, None, [])
-
    Test many2many operator with empty search list
-
    !assert {model: res.partner, search: "[('category_id', 'in', [])]", count: 0, string: "Ids should be empty"}
-
    Test many2many operator with False
-
    !assert {model: res.partner, search: "[('category_id', '=', False)]"}:
        - category_id in (False, None, [])
-
    Filtering on invalid value across x2many relationship should return an empty set
-
    !assert {model: res.partner, search: "[('address.city','=','foo')]", count: 0, string: "Searching for address.city = foo should give empty results"}
-
    Check if many2one works with empty search list
-
    !assert {model: res.partner, search: "[('company_id','in', [])]", count: 0, string: "Searching for company_id in [] should be empty!" }
-
    For the sake of the following tests, I will create a second company
-
    !record {model: res.company, id: ymltest_company2}:
        name: Acme 2
-
    And create a few partners with that company or no company
-
    !python {model: res.partner }: |
        for r in range(4):
            self.create(cr, uid, { 'name': 'P of Acme %d' % r,
                    'company_id': ref('ymltest_company2') })
        for r in range(4):
            self.create(cr, uid, { 'name': 'P of All %d' % r,
                    'company_id': False })
-
    Check if many2one works with negative empty list
-
    !python {model: res.partner }: |
        all_ids = self.search(cr, uid, [])
        all_ids.sort()
        res_ids = self.search(cr, uid,['|',('company_id','not in', []), ('company_id','=',False)])
        res_ids.sort()
        assert all_ids == res_ids, "not in [] fails"
-
    Check that many2one will pick the correct records with a list
-
    !python {model: res.partner }: |
        res_ids = self.search(cr, uid, [('company_id', 'in', [False,])])
        assert len(res_ids) >= 4, "We created 4 partners w/company, why find %d? %r" % \
                    (len(res_ids), res_ids)
-
    Check that many2one will exclude the correct records with a list
-
    !python {model: res.partner }: |
        # assuming that the default company is #1
        res_ids = self.search(cr, uid, [('company_id', 'not in', [1])])
        assert len(res_ids) >= 4, "We should have found 4 records at least, only have %d! %r" % \
            (len(res_ids), res_ids)
-
    Check that we exclude the correct records, + False
-
    !python {model: res.partner }: |
        # assuming that the default company is #1
        res_ids = self.search(cr, uid, ['|', ('company_id', 'not in', [1]), ('company_id', '=', False)])
        assert len(res_ids) >= 8, "We should have found 8 records at least, only have %d! %r" % \
            (len(res_ids), res_ids)
-
    Check that multi-level expressions also work
-
    !python {model: res.partner }: |
        res_ids = self.search(cr, uid, [('company_id.partner_id', 'in', [])])
        assert res_ids == [], "Searching an empty set should return empty result, not %r" % res_ids
-
    Check that multi-level expressions with negative op work
-
    !python {model: res.partner }: |
        all_ids = self.search(cr, uid, [('company_id', '!=', False)])
        all_ids.sort()
        res_ids = self.search(cr, uid, [('company_id.partner_id', 'not in', [])])
        res_ids.sort()
        assert res_ids == all_ids, "Searching against empty set failed, returns %r" % res_ids
-
    Test the '(not) like/in' behavior. res.partner and its parent_id column are used because
    parent_id is a many2one, allowing to test the Null value, and there are actually some
    null and non-null values in the demo data.
-
    !python {model: res.partner }: |
        partner_ids = self.search(cr, uid, [])
        partner_ids.sort()
        max_partner_id = max(partner_ids)
        partners = self.browse(cr, uid, partner_ids)
        with_parent = []
        without_parent = []
        for x in partners:
            if x.parent_id and x.parent_id.id in partner_ids:
                with_parent.append(x.id)
        for x in partners:
            if not x.parent_id:
                without_parent.append(x.id)
        with_website = []
        for x in partners:
            if x.website:
                with_website.append(x.id)
        with_website.sort()
        print "with_parent", with_parent
        print "without_parent", without_parent
        res_0 = self.search(cr, uid, [('parent_id', 'not like', 'probably_unexisting_name')])
        res_1 = self.search(cr, uid, [('parent_id', 'not in', [max_partner_id + 1])])
        res_2 = self.search(cr, uid, [('parent_id', 'not in', False)])
        res_3 = self.search(cr, uid, [('parent_id', 'not in', [])])
        res_4 = self.search(cr, uid, [('parent_id', 'not in', [False])])
        print ">>>  0:", res_0
        print ">>>  1:", res_1
        print ">>>  2:", res_2
        print ">>>  3:", res_3
        print ">>>  4:", res_4
        print ">>> ----------"
        res_5 = self.search(cr, uid, [('parent_id', 'like', 'probably_unexisting_name')])
        res_6 = self.search(cr, uid, [('parent_id', 'in', [max_partner_id + 1])])
        res_7 = self.search(cr, uid, [('parent_id', 'in', False)])
        res_8 = self.search(cr, uid, [('parent_id', 'in', [])])
        res_9 = self.search(cr, uid, [('parent_id', 'in', [False])])
        print ">>>  5:", res_5
        print ">>>  6:", res_6
        print ">>>  7:", res_7
        print ">>>  8:", res_8
        print ">>>  9:", res_9
        print ">>> ----------"
        res_10 = self.search(cr, uid, ['!', ('parent_id', 'like', 'probably_unexisting_name')])
        res_11 = self.search(cr, uid, ['!', ('parent_id', 'in', [max_partner_id + 1])])
        res_12 = self.search(cr, uid, ['!', ('parent_id', 'in', False)])
        res_13 = self.search(cr, uid, ['!', ('parent_id', 'in', [])])
        res_14 = self.search(cr, uid, ['!', ('parent_id', 'in', [False])])
        print ">>> 10:", res_10
        print ">>> 11:", res_11
        print ">>> 12:", res_12
        print ">>> 13:", res_13
        print ">>> 14:", res_14

        # Testing many2one field is not enough, a regular char field is tested
        # with in [] and must not return any result.
        res_15 = self.search(cr, uid, [('website', 'in', [])])
        assert res_15 == []
        # not in [] must return everything.
        res_16 = self.search(cr, uid, [('website', 'not in', [])])
        res_16.sort()
        assert res_16 == partner_ids

        res_17 = self.search(cr, uid, [('website', 'not in', False)])
        res_17.sort()
        assert res_17 == with_website
-
    Property of the query (one2many not in False).
-
    !python {model: res.currency }: |
        ids = self.search(cr, uid, [])
        referenced_companies = set([x.company_id.id for x in self.browse(cr, uid, ids)])
        companies = set(self.pool.get('res.company').search(cr, uid, [('currency_ids', 'not in', False)]))
        assert referenced_companies == companies
-
    Property of the query (one2many in False).
-
    !python {model: res.currency }: |
        ids = self.search(cr, uid, [])
        referenced_companies = set([x.company_id.id for x in self.browse(cr, uid, ids)])
        unreferenced_companies = set(self.pool.get('res.company').search(cr, uid, [])).difference(referenced_companies)
        companies = set(self.pool.get('res.company').search(cr, uid, [('currency_ids', 'in', False)]))
        assert unreferenced_companies == companies
-
    Equivalent queries.
-
    !python {model: res.currency }: |
        max_currency_id = max(self.search(cr, uid, []))
        res_0 = self.search(cr, uid, [])
        res_1 = self.search(cr, uid, [('name', 'not like', 'probably_unexisting_name')])
        res_2 = self.search(cr, uid, [('id', 'not in', [max_currency_id + 1003])])
        res_3 = self.search(cr, uid, [('id', 'not in', [])])
        res_4 = self.search(cr, uid, [('id', 'not in', False)])
        res_0.sort()
        res_1.sort()
        res_2.sort()
        res_3.sort()
        res_4.sort()
        assert res_0 == res_1
        assert res_0 == res_2
        assert res_0 == res_3
        assert res_0 == res_4
-
    Equivalent queries, integer and string.
-
    !python {model: res.partner }: |
        all_ids = self.search(cr, uid, [])
        if len(all_ids) > 1:
            one = all_ids[0]
            record = self.browse(cr, uid, one)
            others = all_ids[1:]
            res_1 = self.search(cr, uid, [('id', '=', one)])
            # self.search(cr, uid, [('id', '!=', others)]) # not permitted
            res_2 = self.search(cr, uid, [('id', 'not in', others)])
            res_3 = self.search(cr, uid, ['!', ('id', '!=', one)])
            res_4 = self.search(cr, uid, ['!', ('id', 'in', others)])
            # res_5 = self.search(cr, uid, [('id', 'in', one)]) # TODO make it permitted, just like for child_of
            res_6 = self.search(cr, uid, [('id', 'in', [one])])
            res_7 = self.search(cr, uid, [('name', '=', record.name)])
            res_8 = self.search(cr, uid, [('name', 'in', [record.name])])
            # res_9 = self.search(cr, uid, [('name', 'in', record.name)]) # TODO
            assert [one] == res_1
            assert [one] == res_2
            assert [one] == res_3
            assert [one] == res_4
            #assert [one] == res_5
            assert [one] == res_6
            assert [one] == res_7
-
    Need a company with a parent_id.
-
    !record {model: res.company, id: ymltest_company3}:
        name: Acme 3
-
    Need a company with a parent_id.
-
    !record {model: res.company, id: ymltest_company4}:
        name: Acme 4
        parent_id: ymltest_company3
-
    Equivalent queries, one2many.
-
    !python {model: res.company }: |
        # Search the company via its one2many (the one2many must point back at the company).
        company = self.browse(cr, uid, ref('ymltest_company3'))
        max_currency_id = max(self.pool.get('res.currency').search(cr, uid, []))
        currency_ids = self.pool.get('res.currency').search(cr, uid, [('name', 'not like', 'probably_unexisting_name')])
        currency_ids = self.pool.get('res.currency').search(cr, uid, [('id', 'not in', [max_currency_id + 1003])])
        currency_ids = self.pool.get('res.currency').search(cr, uid, [('id', 'not in', [])])
        default_company = self.browse(cr, uid, 1)
        # one2many towards same model
        res_1 = self.search(cr, uid, [('child_ids', 'in', [x.id for x in company.child_ids])])
        res_2 = self.search(cr, uid, [('child_ids', 'in', [company.child_ids[0].id])])
        # one2many towards another model
        res_3 = self.search(cr, uid, [('currency_ids', 'in', [x.id for x in default_company.currency_ids])])
        res_4 = self.search(cr, uid, [('currency_ids', 'in', [default_company.currency_ids[0].id])])
        res_5 = self.search(cr, uid, [('currency_ids', 'in', default_company.currency_ids[0].id)])
        # res_6 = self.search(cr, uid, [('currency_ids', 'in', [default_company.currency_ids[0].name])]) # TODO
        res_7 = self.search(cr, uid, [('currency_ids', '=', default_company.currency_ids[0].name)])
        res_8 = self.search(cr, uid, [('currency_ids', 'like', default_company.currency_ids[0].name)])
        res_9 = self.search(cr, uid, [('currency_ids', 'like', 'probably_unexisting_name')])
        # self.search(cr, uid, [('currency_ids', 'unexisting_op', 'probably_unexisting_name')]) # TODO expected exception

        # get the companies referenced by some currency (this is normally the main company)
        res_10 = self.search(cr, uid, [('currency_ids', 'not like', 'probably_unexisting_name')])
        res_11 = self.search(cr, uid, [('currency_ids', 'not in', [max_currency_id + 1])])
        res_12 = self.search(cr, uid, [('currency_ids', 'not in', False)])
        res_13 = self.search(cr, uid, [('currency_ids', 'not in', [])])
        res_10.sort()
        res_11.sort()
        res_12.sort()
        res_13.sort()
        assert res_1 == [ref('ymltest_company3')]
        assert res_2 == [ref('ymltest_company3')]
        assert res_3 == [1]
        assert res_4 == [1]
        assert res_5 == [1]
        assert res_7 == [1]
        assert res_8 == [1]
        assert res_9 == []
        print ">>> 10:", res_10
        print ">>> 11:", res_11
        #assert res_10 == res_11
        assert res_10 == res_12
        print ">>> 12:", res_12
        assert res_10 == res_13
        print ">>> 13:", res_13

        # child_of x returns x and its children (direct or not).
        company = self.browse(cr, uid, ref('ymltest_company3'))
        expected = [ref('ymltest_company3'), ref('ymltest_company4')]
        expected.sort()
        res_1 = self.search(cr, uid, [('id', 'child_of', [ref('ymltest_company3')])])
        res_1.sort()
        res_2 = self.search(cr, uid, [('id', 'child_of', ref('ymltest_company3'))])
        res_2.sort()
        #res_3 = self.search(cr, uid, [('id', 'child_of', [company.name])]) # TODO
        #res_3.sort()
        res_4 = self.search(cr, uid, [('id', 'child_of', company.name)])
        res_4.sort()
        assert res_1 == expected
        assert res_2 == expected
        #assert res_3 == expected
        assert res_4 == expected
-
    Verify that normalize_domain() works.
-
    !python {model: res.partner}: |
        from osv import expression
        norm_domain = domain = ['&',(1,'=',1),('a','=','b')]
        assert norm_domain == expression.normalize(domain), "Normalized domains should be left untouched"
        domain = [('x','in',['y','z']),('a.v','=','e'),'|','|',('a','=','b'),'!',('c','>','d'),('e','!=','f'),('g','=','h')]
        norm_domain = ['&','&','&'] + domain
        assert norm_domain == expression.normalize(domain), "Non-normalized domains should be properly normalized"



