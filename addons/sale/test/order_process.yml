-
  In order to test process of the Sale Order,
-
  First I check the total amount of the Quotation before Approved.
-
  !assert {model: sale.order, id: order, string: The amount of the Quotation is not correctly computed}:
    - sum([l.price_subtotal for l in order_line]) == amount_untaxed
-
  I confirm the quotation with "Invoice based on deliveries" policy.
-
  !workflow {model: sale.order, action: order_confirm, ref: order}
-
  I check that invoice should not created before dispatch delivery.
-
  !python {model: sale.order}: |
    order = self.pool.get('sale.order').browse(cr, uid, ref("order"))
    assert len(order.invoice_ids) == False, "Invoice should not created."
-
  I check that procurement after confirmed quotation.
-
  !python {model: sale.order}: |
    from datetime import datetime, timedelta
    from dateutil.relativedelta import relativedelta
    from tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT
    order = self.browse(cr, uid, ref("order"))
    for order_line in order.order_line:
        procurement = order_line.procurement_id
        date_planned = datetime.strptime(order.date_order, DEFAULT_SERVER_DATE_FORMAT) + relativedelta(days=order_line.delay or 0.0)
        date_planned = (date_planned - timedelta(days=order.company_id.security_lead)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
        assert procurement.date_planned == date_planned, "Scheduled date is not correspond."
        assert procurement.product_id.id == order_line.product_id.id, "Product is not correspond."
        assert procurement.product_qty == order_line.product_uom_qty, "Qty is not correspond."
        assert procurement.product_uom.id == order_line.product_uom.id, "UOM is not correspond."
        assert procurement.procure_method == order_line.type, "Procurement method is not correspond."
-
  I run the scheduler.
-
  !python {model: procurement.order}: |
    self.run_scheduler(cr, uid)

-
  I check the details of delivery order after confirmed quotation.
-
  !python {model: sale.order}: |
    from datetime import datetime, timedelta
    from dateutil.relativedelta import relativedelta
    from tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT
    sale_order = self.browse(cr, uid, ref("order"))
    assert sale_order.picking_ids, "Delivery order is not created."
    for picking in sale_order.picking_ids:
      assert picking.state == "auto" or "confirmed", "Delivery order should be in 'Waitting Availability' state."
      assert picking.origin == sale_order.name,"Origin of Delivery order is not correspond with sequence number of sale order."
      assert picking.type == 'out',"Shipment should be Outgoing."
      assert picking.move_type == sale_order.picking_policy,"Delivery Method is not corresponding with delivery method of sale order."
      assert picking.address_id.id == sale_order.partner_shipping_id.id,"Shipping Address is not correspond with sale order."
      assert picking.note == sale_order.note,"Notes is not correspond with sale order."
      assert picking.invoice_state == (sale_order.order_policy=='picking' and '2binvoiced') or 'none',"Invoice policy is not correspond with sale order."
      assert len(picking.move_lines) == len(sale_order.order_line), "Total move of delivery order are not corresposning with total sale order lines."
      location_id = sale_order.shop_id.warehouse_id.lot_stock_id.id
      output_id = sale_order.shop_id.warehouse_id.lot_output_id.id
      for move in picking.move_lines:
         order_line = move.sale_line_id
         date_planned = datetime.strptime(sale_order.date_order, DEFAULT_SERVER_DATE_FORMAT) + relativedelta(days=order_line.delay or 0.0)
         date_planned = (date_planned - timedelta(days=sale_order.company_id.security_lead)).strftime(DEFAULT_SERVER_DATETIME_FORMAT)
         assert datetime.strptime(move.date_expected, DEFAULT_SERVER_DATETIME_FORMAT) == datetime.strptime(date_planned, DEFAULT_SERVER_DATETIME_FORMAT), "Excepted Date is not correspond with Planned Date."
         assert move.product_id.id == order_line.product_id.id,"Product is not correspond."
         assert move.product_qty == order_line.product_uom_qty,"Product Quantity is not correspond."
         assert move.product_uom.id == order_line.product_uom.id,"Product UOM is not correspond."
         assert move.product_uos_qty == order_line.product_uos_qty,"Product UOS Quantity is not correspond."
         assert move.product_uos == (order_line.product_uos and order_line.product_uos.id) or order_line.product_uom.id,"Product UOS is not correspond"
         assert move.product_packaging.id == order_line.product_packaging.id,"Product packaging is not correspond."
         assert move.address_id.id == order_line.address_allotment_id.id or sale_order.partner_shipping_id.id,"Address is not correspond"
         #assert move.location_id.id == location_id,"Source Location is not correspond."
         #assert move.location_dest_id == output_id,"Destination Location is not correspond."
         assert move.note == order_line.notes,"Notes is not correspond"
         assert move.price_unit == order_line.product_id.standard_price or 0.0,"Price Unit is not correspond"
-
  Now, I dispatch delivery order.
-
  !python {model: stock.partial.picking}: |
    order = self.pool.get('sale.order').browse(cr, uid, ref("order"))
    for pick in order.picking_ids:
        data = pick.force_assign()
        if data == True:
          partial_id = self.create(cr, uid, {}, context={'active_model': 'stock.picking','active_ids': [pick.id]})
          self.do_partial(cr, uid, [partial_id])
-
  I check sale order to verify shipment.
-
  !python {model: sale.order}: |
    order = self.pool.get('sale.order').browse(cr, uid, ref("order"))
    assert order.shipped == True, "Sale order is not Delivered."
    assert order.picked_rate == 100, "Shipment progress is not 100%."
    assert len(order.invoice_ids) == False, "Invoice should not created on dispatch delivery order."
-
  I make Invoice from Delivery Order.
-
  !python {model: stock.invoice.onshipping}: |
    sale = self.pool.get('sale.order')
    sale_order = sale.browse(cr, uid, ref("order"))
    ship_ids = [x.id for x in sale_order.picking_ids]
    wiz_id = self.create(cr, uid, {'journal_id': ref('account.sales_journal')},
      {'active_ids': ship_ids, 'active_model': 'stock.picking'})
    self.create_invoice(cr, uid, [wiz_id], {"active_ids": ship_ids, "active_id": ship_ids[0]})

-
  I check that Invoice details after dispatched delivery.
-
  !python {model: sale.order}: |
    order = self.browse(cr, uid, ref("order"))
    assert order.invoice_ids, "Invoice is not created."
    ac = order.partner_id.property_account_receivable.id
    journal_ids = self.pool.get('account.journal').search(cr, uid, [('type', '=', 'sale'), ('company_id', '=', order.company_id.id)], limit=1)

    for invoice in order.invoice_ids:
      assert invoice.type == 'out_invoice',"Invoice should be Customer Invoice."
      assert invoice.account_id.id == ac,"Invoice account is not correspond."
      #assert invoice.origin == order.name,"Origin of Invoice is not corresponding with sequence number of sale order."
      assert invoice.reference == order.client_order_ref or order.name,"Reference is not correspond."
      assert invoice.partner_id.id == order.partner_id.id,"Customer is not correspond."
      assert invoice.address_invoice_id.id == order.partner_invoice_id.id,"Invoice Address is not correspond."
      assert invoice.currency_id.id == order.pricelist_id.currency_id.id, "Currency is not correspond."
      #assert invoice.comment == order.note,"Notes is not correspond."
      assert invoice.journal_id.id == journal_ids[0],"Sales Journal is not link on Invoice."
      #assert invoice.payment_term.id == order.payment_term and order.payment_term.id or False, "Payment term is not correspond."
      for so_line in order.order_line:
        inv_line = so_line.invoice_lines[0]
        ac = so_line.product_id.product_tmpl_id.property_account_income.id or so_line.product_id.categ_id.property_account_income_categ.id
        assert inv_line.product_id.id == so_line.product_id.id or False,"Product is not correspond"
        assert inv_line.account_id.id == ac,"Account of Invoice line is not corresponding."
        assert inv_line.uos_id.id == so_line.product_uom.id , "UOM is not correspond."
        assert inv_line.price_unit == so_line.price_unit , "Price Unit is not correspond."
        #assert inv_line.quantity == so_line.product_uom_qty , "Product qty is not correspond."
        #assert inv_line.price_subtotal == so_line.price_subtotal, "Price sub total is not correspond."

-
  Now I confirm the Quotation with "Invoice on order after delivery" policy.
-
  !workflow {model: sale.order, action: order_confirm, ref: order2}
-
  I check that related delivery order after confirmed.
-
  !python {model: sale.order}: |
    sale_order = self.browse(cr, uid, ref("order2"))
    assert sale_order.picking_ids, "Delivery Order should be created."
    assert len(sale_order.invoice_ids) == False, "Invoice should be not created."
-
  Now, I dispatch delivery order.
-
  !python {model: stock.partial.picking}: |
    order = self.pool.get('sale.order').browse(cr, uid, ref("order2"))
    for pick in order.picking_ids:
        data = pick.force_assign()
        if data == True:
          partial_id = self.create(cr, uid, {}, context={'active_model': 'stock.picking','active_ids': [pick.id]})
          self.do_partial(cr, uid, [partial_id])
-
  I check that an invoice has been created.
-
  !python {model: sale.order}: |
    order = self.browse(cr, uid, ref("order2"))
    #assert order.invoice_ids, "Invoice should be created after dispatch delivery order."
-
  Now I confirm the Quotation with "Pay before delivery" policy.
-
  !workflow {model: sale.order, action: order_confirm, ref: order3}
-
  I check that delivery order should not created before invoice is paid.
-
  !python {model: sale.order}: |
    sale_order = self.browse(cr, uid, ref("order3"))
    assert len(sale_order.picking_ids) == False, "Delivery order should not created before invoice."
    assert sale_order.invoice_ids, "Invoice should be created."

-
  I confirm the Quotation with "Deliver & invoice on demand".
-
  !workflow {model: sale.order, action: order_confirm, ref: order4}
-
  I check that Invoice should not created.
-
  !python {model: sale.order}: |
    sale_order = self.browse(cr, uid, ref("order4"))
    assert len(sale_order.invoice_ids) == False, "Invoice should not created."
    assert sale_order.picking_ids, "Delivery order should be created."
-
  I make advance invoice.
-
  !python {model: sale.advance.payment.inv}: |
    ctx = context.copy()
    ctx.update({"active_model": 'sale.order', "active_ids": [ref("order4")], "active_id":ref("order4")})
    order_line = self.pool.get('sale.order.line').browse(cr, uid, ref("line7"), context=context)
    pay_id = self.create(cr, uid, {'product_id': order_line.product_id.id, 'amount': order_line.price_subtotal, 'qtty': order_line.product_uom_qty})
    self.create_invoices(cr, uid, [pay_id], context=ctx)
-
  I check Invoice which made advance
-
  !python {model: sale.order}: |
    order = self.browse(cr, uid, ref('order4'))
    assert order.invoice_ids, "Invoice should be created after make advance invoice."
-
  I make Invoice from sale order line.
-
  !python {model: sale.order.line.make.invoice}: |
    ctx = context.copy()
    ctx.update({"active_model": 'sale.order.line', "active_ids": [ref("line8")], "active_id":ref("line8")})
    self.make_invoices(cr, uid, [], context=ctx)
-
  I check Invoice which made from sale order line.
-
  !python {model: sale.order.line}: |
    line = self.browse(cr, uid, ref('line8'))
    assert line.invoice_lines, "Invoice line should be created."
-
  I make manual Invoice for order.
-
  !record {model: sale.make.invoice, id: sale_make_invoice_1}:
    invoice_date: !eval time.strftime('%Y-%m-%d')
-
  !python {model: sale.make.invoice}: |
    ctx = context.copy()
    ctx = ctx.update({"active_model": 'sale.order', "active_ids": [ref("order4")], "active_id":ref("order4")})
    self.make_invoices(cr, uid, [ref("sale_make_invoice_1")], context)
-
  I check Invoice after do manual.
-
  !python {model: sale.order}: |
    sale_order = self.browse(cr, uid, ref("order4"))
    assert sale_order.invoice_ids, "Invoice should be created."
-
  I open the Invoice.
-
  !python {model: sale.order}: |
    import netsvc
    wf_service = netsvc.LocalService("workflow")
    so = self.browse(cr, uid, ref("order4"))
    for invoice in so.invoice_ids:
      wf_service.trg_validate(uid, 'account.invoice', invoice.id, 'invoice_open', cr)
    assert so.invoiced_rate == 100, "Invoiced Progress is not 100%."

-
  I set order policy "Deliver & invoice on demand" as default policy.
-
  !record {model: sale.config.picking_policy, id: sale.config.picking_policy_0}:
    order_policy: 'manual'
-
  !python {model: sale.config.picking_policy}: |
    self.execute(cr, uid, [ref("sale.config.picking_policy_0")])
-
  I print a sale order report.
-
  !python {model: sale.order}: |
    import netsvc, tools, os
    (data, format) = netsvc.LocalService('report.sale.order').create(cr, uid, [ref('order')], {}, {})
    if tools.config['test_report_directory']:
        file(os.path.join(tools.config['test_report_directory'], 'sale-sale_order.'+format), 'wb+').write(data)
