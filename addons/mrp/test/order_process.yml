-
  I change production qty with 3 Dozen Shelf 100cm.
-
  !python {model: change.production.qty}: |
    context.update({'active_id': ref('mrp_production_shelf100cm')})
-
  !record {model: change.production.qty, id: mrp_production_qty}:
    product_qty: 3.0
-
  !python {model: change.production.qty}: |
    self.change_prod_qty(cr, uid, [ref("mrp_production_qty")], context=context)
-
  I check qty after changed in production order.
-
  !python {model: mrp.production}: |
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    assert move.product_uom.id == ref("product.product_uom_dozen"), "UOM is not correspond."
    assert move.product_qty == 3, "Qty is not changed."
-
  I compute the production order.
-
  !python {model: mrp.production}: |
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"), context=context)
    order.action_compute()
-
  I check production lines after compute.
-
  !python {model: mrp.production}: |
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"), context=context)
    assert len(order.move_lines), "Production lines are not generated."
    for line in order.move_lines:
        if line.product_id.id == ref('product.product_product_assemblysection0'):
            assert line.product_qty == (4.0*3.0*12.0), "Qty is not correspond."
            assert line.product_uom.id == ref('product.product_uom_unit'), "UOM is not correspond"
        elif line.product_id.id == ref('product.product_product_sidepanel0'):
            assert line.product_qty == (2.0*3.0*12.0), "Qty is not correspond."
            assert line.product_uom.id == ref('product.product_uom_unit'), "UOM is not correspond"
        elif line.product_id.id == ref('product.product_product_metalcleats0'):
            assert line.product_qty == (12.0*3.0*12.0), "Qty is not correspond."
            assert line.product_uom.id == ref('product.product_uom_unit'), "UOM is not correspond"
        elif line.product_id.id == ref('product.product_product_rearpanelarm0'):
            assert line.product_qty == (1.0*3.0*12.0), "Qty is not correspond."
            assert line.product_uom.id == ref('product.product_uom_unit'), "UOM is not correspond"
        elif line.product_id.id == ref('product.product_product_shelf0'):
            assert line.product_qty == (3.0*3.0*12.0), "Qty is not correspond."
            assert line.product_uom.id == ref('product.product_uom_unit'), "UOM is not correspond"
        else:
            assert_exception("Lines are not correspond.")
-
  I confirm the Production Order.
-
  !workflow {model: mrp.production, action: button_confirm, ref: mrp_production_shelf100cm}
-
  I check details of Produce Move of Production Order to trace Final Product.
-
  !python {model: mrp.production}: |
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    assert order.state == 'confirmed', "Production order should be confirmed."
    assert order.move_created_ids, "Trace Record is not created for Final Product."
    move = order.move_created_ids[0]
    source_location_id = order.product_id.product_tmpl_id.property_stock_production.id
    assert move.date == order.date_planned, "Planned date is not correspond."
    assert move.product_id.id == order.product_id.id, "Product is not correspond."
    assert move.product_uom.id == order.product_uom.id, "UOM is not correspond."
    assert move.product_qty == order.product_qty, "Qty is not correspond."
    assert move.product_uos == order.product_uos, "UOS is not correspond."
    assert move.product_uos_qty == order.product_uos_qty, "UOS qty is not correspond."
    assert move.location_id.id == source_location_id, "Source Location is not correspond."
    assert move.location_dest_id.id == order.location_dest_id.id, "Destination Location is not correspond."
    routing_loc = None
    if production.bom_id.routing_id and production.bom_id.routing_id.location_id:
        routing_loc = production.bom_id.routing_id.location_id.id
        
    for move_line in order.move_lines:
        for order_line in order.product_lines:
            if line.product_id.type not in ('product', 'consu'):
                continue
            if move_line.product_id.id == order_line.product_id.id:
                assert move_line.date == date_planned, "Planned date is not correspond in 'To consume line'."
                assert move_line.product_qty == order_line.product_qty, "Qty is not correspond in 'To consume line'."
                assert move_line.product_uom.id == order_line.product_uom.id, "UOM is not correspond in 'To consume line'."
                assert move_line.product_uos_qty == order_line.product_uos and order_line.product_uos_qty or False, "UOS qty is not correspond in 'To consume line'."
                assert move_line.product_uos == order_line.product_uos and order_line.product_uos.id or False, "UOS is not correspond in 'To consume line'."
                assert move_line.location_id.id == routing_loc or production.location_src_id.id, "Source location is not correspond in 'To consume line'."
                assert move_line.location_dest_id.id == source_location_id, "Destination Location is not correspond in 'To consume line'."

-
  I check details of an Internal Shipment after confirmed production order to bring components in Raw Materials Location.
-
  !python {model: mrp.production}: |
    procurement = self.pool.get('procurement.order')
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    assert order.picking_id, 'Internal Shipment should be created!'
    
    routing_loc = None
    pick_type = 'internal'
    address_id = False
    if production.bom_id.routing_id and production.bom_id.routing_id.location_id:
        routing_loc = production.bom_id.routing_id.location_id
        if routing_loc.usage <> 'internal':
            pick_type = 'out'
        address_id = routing_loc.address_id and routing_loc.address_id.id or False
        routing_loc = routing_loc.id
    assert order.picking_id.type == pick_type, "Shipment should be Internal."
    assert order.picking_id.address_id ==  address_id, "Shipment Address is not correspond with Adderss of Routing Location."
    date_planned = production.date_planned
    for move_line in order.picking_id.move_lines:
        for order_line in order.product_lines:
            if line.product_id.type not in ('product', 'consu'):
                continue
            if move_line.product_id.id == order_line.product_id.id:
                assert move_line.date == date_planned, "Planned date is not correspond."
                assert move_line.product_qty == order_line.product_qty, "Qty is not correspond."
                assert move_line.product_uom.id == order_line.product_uom.id, "UOM is not correspond."
                assert move_line.product_uos_qty == order_line.product_uos and order_line.product_uos_qty or False, "UOS qty is not correspond."
                assert move_line.product_uos == order_line.product_uos and order_line.product_uos.id or False, "UOS is not correspond."
                assert move_line.location_id.id == production.location_src_id.id, "Source location is not correspond."
                assert move_line.location_dest_id.id == routing_loc or production.location_src_id.id, "Destination Location is not correspond."
                procurement_ids = procurement.search(cr, uid, [('move_id','=',move_line.id)]
                assert procurement_ids, "Procurement should be created for shipment line of raw materials."
                shipment_procurement = procurement.browse(cr, uid, procurement_ids[0], context=context)
                assert shipment_procurement.date_planned == date_planned, "Planned date is not correspond in procurement."
                assert shipment_procurement.product_id.id == order_line.product_id.id, "Product is not correspond in procurement."
                assert shipment_procurement.product_qty == order_line.product_qty, "Qty is not correspond in procurement."
                assert shipment_procurement.product_uom.id == order_line.product_uom.id, "UOM is not correspond in procurement."
                assert shipment_procurement.product_uos_qty == order_line.product_uos and order_line.product_qty or False, "UOS qty is not correspond in procurement."
                assert shipment_procurement.product_uos.id == order_line.product_uos and order_line.product_uos.id or False, "UOS is not correspond in procurement."
                assert shipment_procurement.location_id.id == production.location_src_id.id, "Location is not correspond in procurement."
                assert shipment_procurement.procure_method == order_line.product_id.procure_method, "Procure method is not correspond in procurement."
   

-  
  I run scheduler.
-
  !python {model: procurement.order}: |
    self.run_scheduler(cr, uid)
-
  The production order is Waiting Goods, I forcefully done internal shipment.
-
  !python {model: mrp.production}: |
    self.force_production(cr, uid, [ref("mrp_production_shelf100cm")])
-
  I check that production order in ready state after forcefully done internal shipment.
-
  !python {model: mrp.production}: |
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    assert order.state == 'ready', 'Production order should be in Ready State.'
    assert order.picking_id.state == 'done', 'Internal shipment should be done.'
-
  Now I start production.
-
  !workflow {model: mrp.production, action: button_produce, ref: mrp_production_shelf100cm}
-
  I check that production order in production state after start production.
-
  !python {model: mrp.production}: |
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    assert order.state == 'in_production', 'Production order should be in production State.'
-
  I consume raw materials and put one material in scrap location due to waste it.
-
  !python {model: mrp.production}: |
    scrap_location_ids = self.pool.get('stock.location').search(cr, uid, [('scrap_location','=',True)])
    scrap_location_id = scrap_location_ids[0]
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    for move in order.move_lines:
        move.action_consume(move.product_qty)
        if move.product_id.id == ref("product.product_product_metalcleats0"): 
            move.action_scrap(5.0, scrap_location_id)
-
  I produce product.
-
  !python {model: mrp.product.produce}: |
    context.update({'active_id': ref('mrp_production_shelf100cm')})
-
  !record {model: mrp.product.produce, id: mrp_product_produce1}:
    mode: 'consume_produce'
-
  !python {model: mrp.product.produce}: |
    self.do_produce(cr, uid, [ref('mrp_product_produce1')], context=context)
-
  I check production order after produced.
-
  !assert {model: mrp.production, id: mrp_production_shelf100cm}:
    - state == 'done'

-
  I print a "BOM Structure".
-
  !python {model: mrp.production}: |
    import netsvc, tools, os
    order = self.browse(cr, uid, ref("mrp_production_shelf100cm"))
    (data, format) = netsvc.LocalService('report.bom.structure').create(cr, uid, [order.bom_id.id], {}, {})
    if tools.config['test_report_directory']:
        file(os.path.join(tools.config['test_report_directory'], 'mrp-bom_structure_report.'+format), 'wb+').write(data)

-
  I print "Production Order".
-
  !python {model: mrp.production}: |
    import netsvc, tools, os
    (data, format) = netsvc.LocalService('report.mrp.production.order').create(cr, uid, [ref("mrp_production_shelf100cm")], {}, {})
    if tools.config['test_report_directory']:
        file(os.path.join(tools.config['test_report_directory'], 'mrp-production_order_report.'+format), 'wb+').write(data)

-
  I print  "Work Center Load Report".
-
  !python {model: mrp.workcenter}: |
    ctx = context.copy()
    ctx.update({'model': 'mrp.workcenter','active_ids': [ref('mrp_workcenter_0'),ref('mrp_workcenter_1')]})
    data_dict = {'time_unit': 'day', 'measure_unit': 'hours'}
    from tools import test_reports
    test_reports.try_report_action(cr, uid, 'action_mrp_workcenter_load_wizard',wiz_data=data_dict, context=ctx, our_module='mrp')

