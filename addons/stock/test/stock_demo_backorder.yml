-
  In order to test partial delivery and back orders, I select delivery order and check process on it.
-
  I confirm the Delivery order and make it available .
-
  !python {model: stock.picking}: |
    self.draft_force_assign(cr, uid, [ref('stock.stock_picking_1')], {})
    self.draft_validate(cr, uid, [ref('stock.stock_picking_1')], {})
    try:
      self.action_assign(cr, uid, [ref('stock.stock_picking_1')], {})
    except:
      pass
    self.force_assign(cr, uid, [ref('stock.stock_picking_1')], {})
-
  I add a new move line in the delivery order.
-
  !record {model: stock.move, id: stock_move_3}:
    product_id: product.product_product_fan2
    product_qty: 7.0
    location_dest_id: stock.stock_location_customers
    location_id: stock.stock_location_stock
    picking_id: stock_picking_1
-
  I make partial delivery for the delivery order.
-
  !python {model: stock.picking}: |
    result = self.action_process(cr, uid, [ref('stock.stock_picking_1')], {})['res_id']
    pick = self.pool.get('stock.partial.picking').browse(cr, uid, result, {})
    pick_line = self.pool.get('stock.partial.picking.line')
    for line in pick.move_ids:
        if line.product_id.id == ref('product.product_product_cpu3'):
            pick_line.write(cr, uid, [line.id], {'quantity': 0.0}, {})
        elif line.product_id.id == ref('product.product_product_cpu1'):
            pick_line.write(cr, uid, [line.id], {'quantity': 7.0}, {})
        elif line.product_id.id == ref('product.product_product_fan2'):
            pick_line.write(cr, uid, [line.id], {'quantity': 3.0}, {})
    pick_line.create(cr, uid, {
        'product_id': ref('product.product_product_pc1'),
        'quantity': 2.0,
        'product_uom': ref('product.product_uom_unit'),
        'location_id': ref('stock.stock_location_stock'),
        'location_dest_id': ref('stock.stock_location_customers'),
        'wizard_id': result
    }, {})
    self.pool.get('stock.partial.picking').do_partial(cr, uid, [result], {})
-
  I check the backorder and its moves.
-
  !python {model: stock.picking}: |
    pick = self.browse(cr, uid, ref('stock.stock_picking_1'), {})
    for line in pick.move_lines:
        if line.product_id.id == ref('product.product_product_cpu3'):
            assert line.product_qty == 5.0, "Wrong quantity %s for CPU3 back order" % (line.product_qty,)
        elif line.product_id.id == ref('product.product_product_fan2'):
            assert line.product_qty == 4.0, "Wrong quantity %s for FAN2 back order" % (line.product_qty,)
        elif line.product_id.id == ref('product.product_product_pc1'):
            assert line.product_qty == 0.0, "Wrong quantity for PC1 back order"
        else:
            assert line.product_qty == 0.0, "Wrong quantity for %s back order" % (line.product_id.code,)
-
  After the partial picking of delivery order, I check the backorder and stock moves.
-
  !python {model: stock.picking}: |
    pick = self.browse(cr, uid, ref('stock.stock_picking_1'))
    stock = self.pool.get('stock.move')
    assert pick.state == 'assigned',"After partial picking the remaining product's delivery order must be in 'Ready to process' state"
    assert pick.backorder_id.state == 'done',"The backorder state should be 'Done'"
    done_move = stock.search(cr, uid, [('picking_id','=',pick.backorder_id.id)])
    assign_move = stock.search(cr, uid, [('picking_id','=',pick.id)])
    for move in stock.browse(cr, uid, done_move):
      assert move.state == 'done',"Stock move of %s picking should be in 'Done' state"%(move.picking_id.name)
    for move in stock.browse(cr, uid, assign_move):
     assert move.state == 'assigned' or 'draft',"Stock move of %s picking should be in 'Available' state"%(move.picking_id.name)

