-
  In order to test partial delivery and back orders,
  I select a delivery order of CPU1 and CPU3 product each contain five quantities.
-
  I confirm the picking 'OUT001' and make it available .
-
  !python {model: stock.picking}: |
    self.draft_force_assign(cr, uid, [ref('stock.stock_picking_1')], {})
    self.force_assign(cr, uid, [ref('stock.stock_picking_1')], {})
-
  After confirmed the picking and its two lines,
  I add a new move line in draft state with 'FAN2' of seven quantities.
-
  !record {model: stock.move, id: stock_move_3}:
    product_id: product.product_product_fan2
    product_qty: 7.0
    location_dest_id: stock.stock_location_customers
    location_id: stock.stock_location_stock
    picking_id: stock_picking_1
- |
  I click on 'Process Now' to process the delivery order and I change quantities to:
  seven for CPU1, zero for CPU3, three for FAN2 and a new product PC1 for four quantites for test the partial delivery.
-
  !python {model: stock.picking}: |
    result = self.action_process(cr, uid, [ref('stock.stock_picking_1')], {})['res_id']
    pick = self.pool.get('stock.partial.picking').browse(cr, uid, result, {})
    lobj = self.pool.get('stock.partial.picking.line')
    for line in pick.move_ids:
        if line.product_id.id == ref('product.product_product_cpu3'):
            lobj.write(cr, uid, [line.id], {
                'quantity': 0.0
            }, {})
        elif line.product_id.id == ref('product.product_product_cpu1'):
            lobj.write(cr, uid, [line.id], {
                'quantity': 7.0
            }, {})
        elif line.product_id.id == ref('product.product_product_fan2'):
            lobj.write(cr, uid, [line.id], {
                'quantity': 3.0
            }, {})
    lobj.create(cr, uid, {
        'product_id': ref('product.product_product_pc1'),
        'quantity': 2.0,
        'product_uom': ref('product.product_uom_unit'),
        'location_id': ref('stock.stock_location_stock'),
        'location_dest_id': ref('stock.stock_location_customers'),
        'wizard_id': result
    }, {})
    self.pool.get('stock.partial.picking').do_partial(cr, uid, [result], {})
-
  I test that the back order contains five CPU3 and four FAN2.
-
  !python {model: stock.picking}: |
    pick = self.browse(cr, uid, ref('stock.stock_picking_1'), {})
    for line in pick.move_lines:
        if line.product_id.id == ref('product.product_product_cpu3'):
            assert line.product_qty == 5.0, "Wrong quantity %.2f for CPU3 back order" % (line.product_qty,)
        elif line.product_id.id == ref('product.product_product_fan2'):
            assert line.product_qty == 4.0, "Wrong quantity %.2f for FAN2 back order" % (line.product_qty,)
        elif line.product_id.id == ref('product.product_product_pc1'):
            assert line.product_qty == 0.0, "Wrong quantity for PC1 back order"
        else:
            assert line.product_qty == 0.0, "Wrong quantity for %s back order" % (line.product_id.code,)
-
  After the partial picking I check the delivery order or backorder and stock moves.
-
  !python {model: stock.picking}: |
    result = self.search(cr, uid, [('name','=','OUT/00001')])
    pick = self.pool.get('stock.picking').browse(cr, uid, result)
    stock = self.pool.get('stock.move')
    assert pick[0].state == 'assigned',"After partial picking the remaining product's delivery order must be in 'Ready to process' state"
    assert pick[0].backorder_id.state == 'done',"The backorder state should be 'Done'"
    done_move = stock.search(cr, uid, [('picking_id','=',pick[0].backorder_id.id)])
    assign_move = stock.search(cr, uid, [('picking_id','=',pick[0].id)])
    for move in stock.browse(cr, uid, done_move):
      assert move.state == 'done',"Stock move of %s picking should be in 'Done' state"%(move.picking_id)
    for move in stock.browse(cr, uid, assign_move):
      assert move.state == 'assigned' or 'draft',"Stock move of %s picking should be in 'Available' state"%(move.picking_id)

